<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Setting Up GitHub Actions to Deploy to ECS | Learning with Rick</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction I was excited to tackle today&rsquo;s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my Notes app. One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my last post was done manually in a graphical interface, which wasn&rsquo;t as exciting for me, but was a necessary step in the learning process. So, let&rsquo;s see how I automated part of the deployment process using GitHub Actions.">
<meta name="author" content="">
<link rel="canonical" href="https://rickt.io/posts/08-setting-up-github-actions-to-deploy-to-ecs/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.c298361a052d70fd4ce0d87fac47d88fb063528ceab06c67a460167c3d399bdc.css" integrity="sha256-wpg2GgUtcP1M4Nh/rEfYj7BjUozqsGxnpGAWfD05m9w=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://rickt.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://rickt.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://rickt.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://rickt.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://rickt.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Setting Up GitHub Actions to Deploy to ECS" />
<meta property="og:description" content="Introduction I was excited to tackle today&rsquo;s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my Notes app. One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my last post was done manually in a graphical interface, which wasn&rsquo;t as exciting for me, but was a necessary step in the learning process. So, let&rsquo;s see how I automated part of the deployment process using GitHub Actions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rickt.io/posts/08-setting-up-github-actions-to-deploy-to-ecs/" />
<meta property="og:image" content="https://rickt.io/images/ghactions.svg" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-11-10T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://rickt.io/images/ghactions.svg" />
<meta name="twitter:title" content="Setting Up GitHub Actions to Deploy to ECS"/>
<meta name="twitter:description" content="Introduction I was excited to tackle today&rsquo;s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my Notes app. One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my last post was done manually in a graphical interface, which wasn&rsquo;t as exciting for me, but was a necessary step in the learning process. So, let&rsquo;s see how I automated part of the deployment process using GitHub Actions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://rickt.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Setting Up GitHub Actions to Deploy to ECS",
      "item": "https://rickt.io/posts/08-setting-up-github-actions-to-deploy-to-ecs/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Setting Up GitHub Actions to Deploy to ECS",
  "name": "Setting Up GitHub Actions to Deploy to ECS",
  "description": "Introduction I was excited to tackle today\u0026rsquo;s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my Notes app. One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my last post was done manually in a graphical interface, which wasn\u0026rsquo;t as exciting for me, but was a necessary step in the learning process. So, let\u0026rsquo;s see how I automated part of the deployment process using GitHub Actions.",
  "keywords": [
    
  ],
  "articleBody": "Introduction I was excited to tackle today’s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my Notes app. One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my last post was done manually in a graphical interface, which wasn’t as exciting for me, but was a necessary step in the learning process. So, let’s see how I automated part of the deployment process using GitHub Actions.\nSetup Create workflow in GitHub Actions After looking at some guides, I started by going to the repo for my Notes app and going to the Actions tab, then New Workflow. From there I searched for “ECS” and selected the one result - Deploy to Amazon ECS.\nI think this was a good place to start, but I realized halfway through that this template was a bit out of date. I ended up having to pull pieces from other specific workflows to update most sections. This Github Docs page along with the official AWS Actions helped me figure out all the modifications I ended up needing to make.\nCreate JSON task definition for ECS The next thing I needed to do was to get the JSON version of the task definition that I created in my last post. I did this by going to ECS in the AWS console, then Task definitions, selecting my task - notes-api-task, selecting the latest revision, and selecting the JSON tab. I now know another way to do this via the AWS CLI:\naws ecs list-task-definitions Which will give you the ARN to use the following command to get the JSON:\naws ecs describe-task-definition --task-definition arn:aws:ecs:us-west-2::task-definition/notes-api-task So I copied the JSON and pasted into a file in the root of my notes project folder and called it notes-api-task.json. I also found out later that I needed to modify this task definition.\nAdd service to ECS cluster Next, I needed to stop the existing task running in my ECS cluster and change it to a service. I stopped the existing task by going to the ECS console, then my notes-api cluster, then the Tasks tab, selected the running task, and hit Stop.\nTo create the service, I went to Services tab in my ECS cluster, clicked Create, and changed the following:\nLaunch type: EC2\nTask definition - Family: notes-api-task (created previously)\nService name: notes-api-service\nWith the task definition and service in place, I went back to the GitHub Actions workflow and edited the environment variables it had:\nenv: AWS_REGION: us-west-2  # set this to your preferred AWS region, e.g. us-west-1 ECR_REPOSITORY: notes-api  # set this to your Amazon ECR repository name ECS_SERVICE: notes-api-service  # set this to your Amazon ECS service name ECS_CLUSTER: notes-api  # set this to your Amazon ECS cluster name ECS_TASK_DEFINITION: notes-api-task.json # set this to the path to your Amazon ECS task definition # file, e.g. .aws/task-definition.json CONTAINER_NAME: notes-api-container  # set this to the name of the container in the # containerDefinitions section of your task definition  It looked like I had everything in place, so I made a new commit to the main branch to kick off the workflow and it errored on the first real step - AWS credentials.\nIt seemed obvious as I saw it and from there I went down a bit of a rabbit hole of methods and best practices for authorizing GitHub to talk to AWS.\nConnect GitHub to AWS Add identity provider to AWS After some reading and consideration, I decided to use the OpenID Connect (OIDC) method for authentication as it seemed to be the best practice as well as being simple enough to learn in one sitting. I started by going to the IAM console in AWS, then Indentity providers, and clicked Add provider.\nI then entered the following:\n Provider type: OpenID Connect Provider URL: token.actions.githubusercontent.com Audience sts.amazonaws.com  Create role for GitHub Actions Then I added a role for GitHub Actions by going to Roles within IAM, then Create role. I selected Custom trust policy and added the following JSON:\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": \"sts:AssumeRoleWithWebIdentity\", \"Principal\": { \"Federated\": \"arn:aws:iam:::oidc-provider/token.actions.githubusercontent.com\" }, \"Condition\": { \"StringLike\": { \"token.actions.githubusercontent.com:sub\": \"repo:rickthackeray/notes:*\" }, \"StringEquals\": { \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\" } } } ] } With that, I pushed a commit to kick off a new instance of the workflow and saw success! Well, I got a check mark for the first section: “Configure AWS credentials” - it failed on the very next one: “Login to Amazon ECR”.\nAdd permission to authenticate with ECR To remedy this, I went to the IAM console, then Roles, and selected my “github-actions” role. From there I went to Permissions, Add Permissions, and Create Inline Policy. I then selected the JSON tab and added this:\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"GetAuthorizationToken\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:GetAuthorizationToken\" ], \"Resource\": \"*\" } ] } I then pushed a new commit to rerun the workflow and got a second check mark! Of course it failed on the step after that.\nBuild, tag, and push Docker image to ECR I was at 2/5 for successful steps in my workflow. Up to this point I didn’t need to modify the workflow template other than inserting the initial configuration settings in the form of environment variables. That was about to change.\nThe error on this step was that it couldn’t find the Dockerfile. I realized that my folder structure was the culprit. See, the Dockerfile and the rest of the code for this part of the app was in a subfolder: “backend”. I fixed this by changing the run command, adding cd backend. The final version of the step looked like this:\n- name: Build, tag, and push docker image to Amazon ECR env: REGISTRY: ${{ steps.login-ecr.outputs.registry }} REPOSITORY: ${{ env.ECR_REPOSITORY }} IMAGE_TAG: ${{ env.IMAGE_TAG }} run: |cd backend docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG . docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG I suspect there are better ways to do this and I look forward to learning that one day.\nI could see in the Workflow log that the image was successfully building, but there was still an error on this step that indicated my “github-actions” role didn’t have the right permissions. I eventually fixed it by adding the following inline policy to the role:\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"AllowPushPull\", \"Effect\": \"Allow\", \"Action\": [ \"ecr:BatchGetImage\", \"ecr:BatchCheckLayerAvailability\", \"ecr:CompleteLayerUpload\", \"ecr:GetDownloadUrlForLayer\", \"ecr:InitiateLayerUpload\", \"ecr:PutImage\", \"ecr:UploadLayerPart\" ], \"Resource\": \"arn:aws:ecr:us-west-2::repository/*\" } ] } With that in place, I got another check mark - 3/5!\nAnd the next step failed, unsurprisingly. I was getting an error that it couldn’t update the task definition with the new image.\nConfigure workflow to update ECS task definition One of the problems seemed to be related to the filename format for the image. The workflow was using the hash of the commit to tag the new build. So, I tried setting it to a static name of “Latest” and that worked. I’m sure there was a way to get the dynamic tagging convention to work, but it wasn’t necessary at this point.\nThis didn’t get me the next check mark, though. The new error sounded like a permissions issue. I struggled with finding the right specific permissions for ECS that the workflow needed. So, I ended up opening it up fully for ECS. This is not ideal in an environment where security is important as it does not meet the principle of least privilege, but it allowed me to continue learning in my fairly low risk environment. Here is the policy that I added to my github-actions role:\n{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"ecs:*\" ], \"Resource\": \"*\" } ] } After that, I pushed a new commit and got another check mark - 4/5! It was time to get that last one!\nConfigure workflow to deploy ECS task This one was possibly the most difficult. The workflow logs weren’t really giving an error - just showing that the attempt at deploying the ECS task was timing out. It took a lot of troubleshooting effort to find out that the issue was with how I was handling secrets that the app needed.\nYou can see in a previous post that I used the volume feature of Docker to add a keys.env file at image runtime. The problem was that the EC2 instance that ECS was controlling didn’t have this file and the task definition didn’t have the volume parameter for the docker run command configured.\nTo get the keys.env file onto the EC2 instance, I simply used scp to copy it over. I’m guessing this isn’t how this is typically done, as I can see issues coming up when working with a team or at larger scales, but again it allowed me to continue learning more instead of fixating on something with lower return. The phrase “Don’t let perfect be the enemy of good” comes to mind.\nAnyway, I could tell by ssh’ing into the EC2 instance and manually running the container that this worked, but I still needed to update the task definition to include the file as a Docker volume at runtime. I did that by modifying the notes-api-task.json file I created before, adding mountPoints and volumes sections. Here is what the file ended up as:\n{ \"taskDefinitionArn\": \"arn:aws:ecs:us-west-2::task-definition/notes-api-task:9\", \"containerDefinitions\": [ { \"name\": \"notes-api-container\", \"image\": \".dkr.ecr.us-west-2.amazonaws.com/notes-api\", \"cpu\": 0, \"portMappings\": [ { \"name\": \"notes-api-container-8000-tcp\", \"containerPort\": 8000, \"hostPort\": 80, \"protocol\": \"tcp\" } ], \"essential\": true, \"environment\": [], \"mountPoints\": [ { \"sourceVolume\": \"keys\", \"containerPath\": \"/app/keys.env\", \"readOnly\": false } ], \"volumesFrom\": [] } ], \"family\": \"notes-api-task\", \"revision\": 9, \"volumes\": [ { \"name\": \"keys\", \"host\": { \"sourcePath\": \"/home/ec2-user/keys.env\" } } ], \"status\": \"ACTIVE\", \"requiresAttributes\": [ { \"name\": \"com.amazonaws.ecs.capability.ecr-auth\" } ], \"placementConstraints\": [], \"compatibilities\": [ \"EC2\" ], \"requiresCompatibilities\": [ \"EC2\" ], \"cpu\": \"1024\", \"memory\": \"100\", \"registeredAt\": \"2023-11-15T01:19:16.910Z\", \"registeredBy\": \"arn:aws:iam:::user/\", \"tags\": [] } One more commit later and I had 5/5 check marks!\nConclusion I successfully set up my first CI/CD pipeline with Github Actions. I can now work on the backend of my notes app and easily deploy new versions to production by simply pushing a new commit to the main branch.\nI really enjoyed this one. It was so gratifying to put in a lot of effort and to see the results of that effort in the form of check marks when each step succeeded. There were certainly times I entered a kind of flow state working on this where the rest of the world dissolved away. I look forward to learning more and putting in the kind of effort that can lead to such a lovely state.\nYou can see the Notes app in action here: http://notes.rickt.io/\nCheers!\nRick\n   Resources  Configuring OpenID Connect in Amazon Web Services (Github Docs) - https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services Connecting GitHub Actions To AWS Using OIDC (StratusGrid) - https://www.youtube.com/watch?v=mel6N62WZb0 Deploying to Amazon Elastic Container Service (Github Docs) - https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service  ",
  "wordCount" : "1818",
  "inLanguage": "en",
  "image":"https://rickt.io/images/ghactions.svg","datePublished": "2023-11-10T00:00:00Z",
  "dateModified": "2023-11-10T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://rickt.io/posts/08-setting-up-github-actions-to-deploy-to-ecs/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Learning with Rick",
    "logo": {
      "@type": "ImageObject",
      "url": "https://rickt.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://rickt.io/" accesskey="h" title="Learning with Rick (Alt + H)">Learning with Rick</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://rickt.io/">Home</a>&nbsp;»&nbsp;<a href="https://rickt.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Setting Up GitHub Actions to Deploy to ECS
    </h1>
    <div class="post-meta"><span title='2023-11-10 00:00:00 +0000 UTC'>November 10, 2023</span>&nbsp;·&nbsp;9 min

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://rickt.io/images/ghactions.svg" alt="">
        
</figure>
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>I was excited to tackle today&rsquo;s topic of using a CI/CD tool, GitHub Actions, to automate part of the deployment of my <a href="https://rickt.io/posts/04-creating-a-basic-notes-app-using-the-farm-stack/">Notes app</a>.  One of my favorite aspects of working with technology is getting to automate things. Much of what I built in my <a href="https://rickt.io/posts/07-deploying-fastapi-to-aws-ecs/">last post</a> was done manually in a graphical interface, which wasn&rsquo;t as exciting for me, but was a necessary step in the learning process. So, let&rsquo;s see how I automated part of the deployment process using GitHub Actions.</p>
<h2 id="setup">Setup<a hidden class="anchor" aria-hidden="true" href="#setup">#</a></h2>
<h4 id="create-workflow-in-github-actions">Create workflow in GitHub Actions<a hidden class="anchor" aria-hidden="true" href="#create-workflow-in-github-actions">#</a></h4>
<p>After looking at some guides, I started by going to the <a href="https://github.com/rickthackeray/notes">repo for my Notes app</a> and going to the <strong>Actions</strong> tab, then <strong>New Workflow</strong>. From there I searched for &ldquo;ECS&rdquo; and selected the one result - <strong>Deploy to Amazon ECS</strong>.</p>
<p>I think this was a good place to start, but I realized halfway through that this template was a bit out of date. I ended up having to pull pieces from other specific workflows to update most sections. <a href="https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service">This Github Docs page</a> along with the official <a href="https://github.com/aws-actions">AWS Actions</a> helped me figure out all the modifications I ended up needing to make.</p>
<h4 id="create-json-task-definition-for-ecs">Create JSON task definition for ECS<a hidden class="anchor" aria-hidden="true" href="#create-json-task-definition-for-ecs">#</a></h4>
<p>The next thing I needed to do was to get the JSON version of the task definition that I created in my <a href="https://rickt.io/posts/07-deploying-fastapi-to-aws-ecs/">last post</a>. I did this by going to <strong>ECS</strong> in the AWS console, then <strong>Task definitions</strong>, selecting my task - <strong>notes-api-task</strong>, selecting the latest revision, and selecting the <strong>JSON</strong> tab. I now know another way to do this via the AWS CLI:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">aws ecs list-task-definitions
</code></pre></div><p>Which will give you the ARN to use the following command to get the JSON:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">aws ecs describe-task-definition --task-definition arn:aws:ecs:us-west-2:&lt;AWS ID&gt;:task-definition/notes-api-task
</code></pre></div><p>So I copied the JSON and pasted into a file in the root of my notes project folder and called it <code>notes-api-task.json</code>. I also found out later that I needed to modify this task definition.</p>
<h4 id="add-service-to-ecs-cluster">Add service to ECS cluster<a hidden class="anchor" aria-hidden="true" href="#add-service-to-ecs-cluster">#</a></h4>
<p>Next, I needed to stop the existing task running in my ECS cluster and change it to a service. I stopped the existing task by going to the <strong>ECS</strong> console, then my <strong>notes-api</strong> cluster, then the <strong>Tasks</strong> tab, selected the running task, and hit <strong>Stop</strong>.</p>
<p>To create the service, I went to <strong>Services</strong> tab in my ECS cluster, clicked <strong>Create</strong>, and changed the following:</p>
<p><strong>Launch type</strong>: EC2<br>
<strong>Task definition - Family</strong>: notes-api-task (created previously)<br>
<strong>Service name</strong>: notes-api-service</p>
<p>With the task definition and service in place, I went back to the GitHub Actions workflow and edited the environment variables it had:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml"><span style="color:#f92672">env</span>:
  <span style="color:#f92672">AWS_REGION</span>: <span style="color:#ae81ff">us-west-2                  </span> <span style="color:#75715e"># set this to your preferred AWS region, e.g. us-west-1</span>
  <span style="color:#f92672">ECR_REPOSITORY</span>: <span style="color:#ae81ff">notes-api          </span> <span style="color:#75715e"># set this to your Amazon ECR repository name</span>
  <span style="color:#f92672">ECS_SERVICE</span>: <span style="color:#ae81ff">notes-api-service                </span> <span style="color:#75715e"># set this to your Amazon ECS service name</span>
  <span style="color:#f92672">ECS_CLUSTER</span>: <span style="color:#ae81ff">notes-api                </span> <span style="color:#75715e"># set this to your Amazon ECS cluster name</span>
  <span style="color:#f92672">ECS_TASK_DEFINITION</span>: <span style="color:#ae81ff">notes-api-task.json</span> <span style="color:#75715e"># set this to the path to your Amazon ECS task definition</span>
                                               <span style="color:#75715e"># file, e.g. .aws/task-definition.json</span>
  <span style="color:#f92672">CONTAINER_NAME</span>: <span style="color:#ae81ff">notes-api-container          </span> <span style="color:#75715e"># set this to the name of the container in the</span>
                                               <span style="color:#75715e"># containerDefinitions section of your task definition                                       </span>
</code></pre></div><p>It looked like I had everything in place, so I made a new commit to the main branch to kick off the workflow and it errored on the first real step - AWS credentials.</p>
<p><img loading="lazy" src="/images/2023-11-20_01.png#center" alt="screenshot"  />
</p>
<p>It seemed obvious as I saw it and from there I went down a bit of a rabbit hole of methods and best practices for authorizing GitHub to talk to AWS.</p>
<h2 id="connect-github-to-aws">Connect GitHub to AWS<a hidden class="anchor" aria-hidden="true" href="#connect-github-to-aws">#</a></h2>
<h4 id="add-identity-provider-to-aws">Add identity provider to AWS<a hidden class="anchor" aria-hidden="true" href="#add-identity-provider-to-aws">#</a></h4>
<p>After some reading and consideration, I decided to use the OpenID Connect (OIDC) method for authentication as it seemed to be the best practice as well as being simple enough to learn in one sitting. I started by going to the <strong>IAM</strong> console in AWS, then <strong>Indentity providers</strong>, and clicked <strong>Add provider</strong>.</p>
<p>I then entered the following:</p>
<ul>
<li><strong>Provider type</strong>: OpenID Connect</li>
<li><strong>Provider URL</strong>: token.actions.githubusercontent.com</li>
<li><strong>Audience</strong> sts.amazonaws.com</li>
</ul>
<h4 id="create-role-for-github-actions">Create role for GitHub Actions<a hidden class="anchor" aria-hidden="true" href="#create-role-for-github-actions">#</a></h4>
<p>Then I added a role for GitHub Actions by going to <strong>Roles</strong> within IAM, then <strong>Create role</strong>. I selected <strong>Custom trust policy</strong> and added the following JSON:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
	<span style="color:#f92672">&#34;Version&#34;</span>: <span style="color:#e6db74">&#34;2012-10-17&#34;</span>,
	<span style="color:#f92672">&#34;Statement&#34;</span>: [
		{
			<span style="color:#f92672">&#34;Effect&#34;</span>: <span style="color:#e6db74">&#34;Allow&#34;</span>,
			<span style="color:#f92672">&#34;Action&#34;</span>: <span style="color:#e6db74">&#34;sts:AssumeRoleWithWebIdentity&#34;</span>,
			<span style="color:#f92672">&#34;Principal&#34;</span>: {
				<span style="color:#f92672">&#34;Federated&#34;</span>: <span style="color:#e6db74">&#34;arn:aws:iam::&lt;AWS ID&gt;:oidc-provider/token.actions.githubusercontent.com&#34;</span>
			},
			<span style="color:#f92672">&#34;Condition&#34;</span>: {
				<span style="color:#f92672">&#34;StringLike&#34;</span>: {
					<span style="color:#f92672">&#34;token.actions.githubusercontent.com:sub&#34;</span>: <span style="color:#e6db74">&#34;repo:rickthackeray/notes:*&#34;</span>
				},
				<span style="color:#f92672">&#34;StringEquals&#34;</span>: {
					<span style="color:#f92672">&#34;token.actions.githubusercontent.com:aud&#34;</span>: <span style="color:#e6db74">&#34;sts.amazonaws.com&#34;</span>
				}
			}
		}
	]
}
</code></pre></div><p>With that, I pushed a commit to kick off a new instance of the workflow and saw success! Well, I got a check mark for the first section: &ldquo;Configure AWS credentials&rdquo; - it failed on the very next one: &ldquo;Login to Amazon ECR&rdquo;.</p>
<h4 id="add-permission-to-authenticate-with-ecr">Add permission to authenticate with ECR<a hidden class="anchor" aria-hidden="true" href="#add-permission-to-authenticate-with-ecr">#</a></h4>
<p>To remedy this, I went to the <strong>IAM</strong> console, then <strong>Roles</strong>, and selected my &ldquo;github-actions&rdquo; role. From there I went to <strong>Permissions</strong>, <strong>Add Permissions</strong>, and <strong>Create Inline Policy</strong>. I then selected the <strong>JSON</strong> tab and added this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
	<span style="color:#f92672">&#34;Version&#34;</span>: <span style="color:#e6db74">&#34;2012-10-17&#34;</span>,
	<span style="color:#f92672">&#34;Statement&#34;</span>: [
		{
			<span style="color:#f92672">&#34;Sid&#34;</span>: <span style="color:#e6db74">&#34;GetAuthorizationToken&#34;</span>,
			<span style="color:#f92672">&#34;Effect&#34;</span>: <span style="color:#e6db74">&#34;Allow&#34;</span>,
			<span style="color:#f92672">&#34;Action&#34;</span>: [
				<span style="color:#e6db74">&#34;ecr:GetAuthorizationToken&#34;</span>
			],
			<span style="color:#f92672">&#34;Resource&#34;</span>: <span style="color:#e6db74">&#34;*&#34;</span>
		}
	]
}
</code></pre></div><p>I then pushed a new commit to rerun the workflow and got a second check mark! Of course it failed on the step after that.</p>
<p><img loading="lazy" src="/images/2023-11-20_02.png#center" alt="screenshot"  />
</p>
<h2 id="build-tag-and-push-docker-image-to-ecr">Build, tag, and push Docker image to ECR<a hidden class="anchor" aria-hidden="true" href="#build-tag-and-push-docker-image-to-ecr">#</a></h2>
<p>I was at 2/5 for successful steps in my workflow. Up to this point I didn&rsquo;t need to modify the workflow template other than inserting the initial configuration settings in the form of environment variables. That was about to change.</p>
<p>The error on this step was that it couldn&rsquo;t find the Dockerfile. I realized that my folder structure was the culprit. See, the Dockerfile and the rest of the code for this part of the app was in a subfolder: &ldquo;backend&rdquo;. I fixed this by changing the run command, adding <code>cd backend</code>. The final version of the step looked like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-yaml" data-lang="yaml">    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Build, tag, and push docker image to Amazon ECR</span>
      <span style="color:#f92672">env</span>:
        <span style="color:#f92672">REGISTRY</span>: <span style="color:#ae81ff">${{ steps.login-ecr.outputs.registry }}</span>
        <span style="color:#f92672">REPOSITORY</span>: <span style="color:#ae81ff">${{ env.ECR_REPOSITORY }}</span>
        <span style="color:#f92672">IMAGE_TAG</span>: <span style="color:#ae81ff">${{ env.IMAGE_TAG }}</span>
      <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span><span style="color:#e6db74">        cd backend
</span><span style="color:#e6db74">        docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
</span><span style="color:#e6db74">        docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG</span>        

</code></pre></div><p>I suspect there are better ways to do this and I look forward to learning that one day.</p>
<p>I could see in the Workflow log that the image was successfully building, but there was still an error on this step that indicated my &ldquo;github-actions&rdquo; role didn&rsquo;t have the right permissions. I eventually fixed it by adding the following inline policy to the role:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
	<span style="color:#f92672">&#34;Version&#34;</span>: <span style="color:#e6db74">&#34;2012-10-17&#34;</span>,
	<span style="color:#f92672">&#34;Statement&#34;</span>: [
		{
			<span style="color:#f92672">&#34;Sid&#34;</span>: <span style="color:#e6db74">&#34;AllowPushPull&#34;</span>,
			<span style="color:#f92672">&#34;Effect&#34;</span>: <span style="color:#e6db74">&#34;Allow&#34;</span>,
			<span style="color:#f92672">&#34;Action&#34;</span>: [
				<span style="color:#e6db74">&#34;ecr:BatchGetImage&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:BatchCheckLayerAvailability&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:CompleteLayerUpload&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:GetDownloadUrlForLayer&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:InitiateLayerUpload&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:PutImage&#34;</span>,
				<span style="color:#e6db74">&#34;ecr:UploadLayerPart&#34;</span>
			],
			<span style="color:#f92672">&#34;Resource&#34;</span>: <span style="color:#e6db74">&#34;arn:aws:ecr:us-west-2:&lt;AWS ID&gt;:repository/*&#34;</span>
		}
	]
}
</code></pre></div><p>With that in place, I got another check mark - 3/5!</p>
<p><img loading="lazy" src="/images/2023-11-20_03.png#center" alt="screenshot"  />
</p>
<p>And the next step failed, unsurprisingly. I was getting an error that it couldn&rsquo;t update the task definition with the new image.</p>
<h2 id="configure-workflow-to-update-ecs-task-definition">Configure workflow to update ECS task definition<a hidden class="anchor" aria-hidden="true" href="#configure-workflow-to-update-ecs-task-definition">#</a></h2>
<p>One of the problems seemed to be related to the filename format for the image. The workflow was using the hash of the commit to tag the new build. So, I tried setting it to a static name of &ldquo;Latest&rdquo; and that worked. I&rsquo;m sure there was a way to get the dynamic tagging convention to work, but it wasn&rsquo;t necessary at this point.</p>
<p>This didn&rsquo;t get me the next check mark, though. The new error sounded like a permissions issue. I struggled with finding the right specific permissions for ECS that the workflow needed. So, I ended up opening it up fully for ECS. This is not ideal in an environment where security is important as it does not meet the principle of least privilege, but it allowed me to continue learning in my fairly low risk environment. Here is the policy that I added to my github-actions role:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
	<span style="color:#f92672">&#34;Version&#34;</span>: <span style="color:#e6db74">&#34;2012-10-17&#34;</span>,
	<span style="color:#f92672">&#34;Statement&#34;</span>: [
		{
			<span style="color:#f92672">&#34;Sid&#34;</span>: <span style="color:#e6db74">&#34;VisualEditor0&#34;</span>,
			<span style="color:#f92672">&#34;Effect&#34;</span>: <span style="color:#e6db74">&#34;Allow&#34;</span>,
			<span style="color:#f92672">&#34;Action&#34;</span>: [
				<span style="color:#e6db74">&#34;ecs:*&#34;</span>
			],
			<span style="color:#f92672">&#34;Resource&#34;</span>: <span style="color:#e6db74">&#34;*&#34;</span>
		}
	]
}
</code></pre></div><p>After that, I pushed a new commit and got another check mark - 4/5! It was time to get that last one!</p>
<h2 id="configure-workflow-to-deploy-ecs-task">Configure workflow to deploy ECS task<a hidden class="anchor" aria-hidden="true" href="#configure-workflow-to-deploy-ecs-task">#</a></h2>
<p>This one was possibly the most difficult. The workflow logs weren&rsquo;t really giving an error - just showing that the attempt at deploying the ECS task was timing out. It took a lot of troubleshooting effort to find out that the issue was with how I was handling secrets that the app needed.</p>
<p>You can see in a <a href="https://rickt.io/posts/06-containerize-a-fastapi-app-with-docker/#handling-secrets">previous post</a> that I used the volume feature of Docker to add a <code>keys.env</code> file at image runtime. The problem was that the EC2 instance that ECS was controlling didn&rsquo;t have this file and the task definition didn&rsquo;t have the volume parameter for the docker run command configured.</p>
<p>To get the <code>keys.env</code> file onto the EC2 instance, I simply used scp to copy it over. I&rsquo;m guessing this isn&rsquo;t how this is typically done, as I can see issues coming up when working with a team or at larger scales, but again it allowed me to continue learning more instead of fixating on something with lower return. The phrase &ldquo;Don&rsquo;t let perfect be the enemy of good&rdquo; comes to mind.</p>
<p>Anyway, I could tell by ssh&rsquo;ing into the EC2 instance and manually running the container that this worked, but I still needed to update the task definition to include the file as a Docker volume at runtime. I did that by modifying the <code>notes-api-task.json</code> file I created before, adding <code>mountPoints</code> and <code>volumes</code> sections. Here is what the file ended up as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#f92672">&#34;taskDefinitionArn&#34;</span>: <span style="color:#e6db74">&#34;arn:aws:ecs:us-west-2:&lt;AWS ID&gt;:task-definition/notes-api-task:9&#34;</span>,
    <span style="color:#f92672">&#34;containerDefinitions&#34;</span>: [
        {
            <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;notes-api-container&#34;</span>,
            <span style="color:#f92672">&#34;image&#34;</span>: <span style="color:#e6db74">&#34;&lt;AWS ID&gt;.dkr.ecr.us-west-2.amazonaws.com/notes-api&#34;</span>,
            <span style="color:#f92672">&#34;cpu&#34;</span>: <span style="color:#ae81ff">0</span>,
            <span style="color:#f92672">&#34;portMappings&#34;</span>: [
                {
                    <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;notes-api-container-8000-tcp&#34;</span>,
                    <span style="color:#f92672">&#34;containerPort&#34;</span>: <span style="color:#ae81ff">8000</span>,
                    <span style="color:#f92672">&#34;hostPort&#34;</span>: <span style="color:#ae81ff">80</span>,
                    <span style="color:#f92672">&#34;protocol&#34;</span>: <span style="color:#e6db74">&#34;tcp&#34;</span>
                }
            ],
            <span style="color:#f92672">&#34;essential&#34;</span>: <span style="color:#66d9ef">true</span>,
            <span style="color:#f92672">&#34;environment&#34;</span>: [],
            <span style="color:#f92672">&#34;mountPoints&#34;</span>: [
                {
                    <span style="color:#f92672">&#34;sourceVolume&#34;</span>: <span style="color:#e6db74">&#34;keys&#34;</span>,
                    <span style="color:#f92672">&#34;containerPath&#34;</span>: <span style="color:#e6db74">&#34;/app/keys.env&#34;</span>,
                    <span style="color:#f92672">&#34;readOnly&#34;</span>: <span style="color:#66d9ef">false</span>
                }
            ],
            <span style="color:#f92672">&#34;volumesFrom&#34;</span>: []
        }
    ],
    <span style="color:#f92672">&#34;family&#34;</span>: <span style="color:#e6db74">&#34;notes-api-task&#34;</span>,
    <span style="color:#f92672">&#34;revision&#34;</span>: <span style="color:#ae81ff">9</span>,
    <span style="color:#f92672">&#34;volumes&#34;</span>: [
        {
            <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;keys&#34;</span>,
            <span style="color:#f92672">&#34;host&#34;</span>: {
                <span style="color:#f92672">&#34;sourcePath&#34;</span>: <span style="color:#e6db74">&#34;/home/ec2-user/keys.env&#34;</span>
            }
        }
    ],
    <span style="color:#f92672">&#34;status&#34;</span>: <span style="color:#e6db74">&#34;ACTIVE&#34;</span>,
    <span style="color:#f92672">&#34;requiresAttributes&#34;</span>: [
        {
            <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;com.amazonaws.ecs.capability.ecr-auth&#34;</span>
        }
    ],
    <span style="color:#f92672">&#34;placementConstraints&#34;</span>: [],
    <span style="color:#f92672">&#34;compatibilities&#34;</span>: [
        <span style="color:#e6db74">&#34;EC2&#34;</span>
    ],
    <span style="color:#f92672">&#34;requiresCompatibilities&#34;</span>: [
        <span style="color:#e6db74">&#34;EC2&#34;</span>
    ],
    <span style="color:#f92672">&#34;cpu&#34;</span>: <span style="color:#e6db74">&#34;1024&#34;</span>,
    <span style="color:#f92672">&#34;memory&#34;</span>: <span style="color:#e6db74">&#34;100&#34;</span>,
    <span style="color:#f92672">&#34;registeredAt&#34;</span>: <span style="color:#e6db74">&#34;2023-11-15T01:19:16.910Z&#34;</span>,
    <span style="color:#f92672">&#34;registeredBy&#34;</span>: <span style="color:#e6db74">&#34;arn:aws:iam::&lt;AWS ID&gt;:user/&lt;AWS USER&gt;&#34;</span>,
    <span style="color:#f92672">&#34;tags&#34;</span>: []
}
</code></pre></div><p>One more commit later and I had 5/5 check marks!</p>
<p><img loading="lazy" src="/images/2023-11-20_04.png#center" alt="screenshot"  />
</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>I successfully set up my first CI/CD pipeline with Github Actions. I can now work on the backend of my notes app and easily deploy new versions to production by simply pushing a new commit to the main branch.</p>
<p>I really enjoyed this one. It was so gratifying to put in a lot of effort and to see the results of that effort in the form of check marks when each step succeeded. There were certainly times I entered a kind of flow state working on this where the rest of the world dissolved away. I look forward to learning more and putting in the kind of effort that can lead to such a lovely state.</p>
<p>You can see the Notes app in action here: <a href="http://notes.rickt.io/">http://notes.rickt.io/</a></p>
<p>Cheers!<br>
Rick</p>
<p> </p>
<p> </p>
<hr>
<h3 id="resources">Resources<a hidden class="anchor" aria-hidden="true" href="#resources">#</a></h3>
<ul>
<li>Configuring OpenID Connect in Amazon Web Services (Github Docs) - <a href="https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services">https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services</a></li>
<li>Connecting GitHub Actions To AWS Using OIDC (StratusGrid) - <a href="https://www.youtube.com/watch?v=mel6N62WZb0">https://www.youtube.com/watch?v=mel6N62WZb0</a></li>
<li>Deploying to Amazon Elastic Container Service (Github Docs) - <a href="https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service">https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-amazon-elastic-container-service</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://rickt.io/posts/09-load-balancing-a-fastapi-app-with-nginx-and-docker/">
    <span class="title">« Prev</span>
    <br>
    <span>Load Balancing Using Nginx and Docker</span>
  </a>
  <a class="next" href="https://rickt.io/posts/07-deploying-fastapi-to-aws-ecs/">
    <span class="title">Next »</span>
    <br>
    <span>Deploying a FastAPI Container to AWS ECS</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://rickt.io/">Learning with Rick</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
